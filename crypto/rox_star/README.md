## rox_star
**Difficulty:** Easy
**Author:** n4siKvn1ng

### Description
x or atau dibaca ex or adalah dasar yang sangat penting untuk kriptografi Karena kriptografi seringkali memanfaatkan kemampuan operasi x or Gimana cara kerjanya silahkan dicoba

### Solution
```python
import random; random.seed(0)

flag = 'NCLPS1{redacted}'
result = ""
for i in range(len(flag)):
	result += hex(ord(flag[i]) ^ random.randint(32, 127))
print(result)

# 0x1f0x160x690x110x320x6f0x280x340x690x230xe0xb0xd0x6e0x370x20x1f0xb0x1f0xc0x4e0x30x4b0x730x730xe0x1a0x150x3f0x680xf0x730x3d0x240x7b0xa0x410x650x140x690x360x60x710x4a0x390x450x180x120x340x4e0x1b0x2f0x4e0x5f0x330x7e0x560x220x3d0x490x5c0xc0x180x41
```

Pada source code yang diberikan menunjukkan bahwa flag dienkripsi dengan XOR dan sebuah bilangan acak yang dihasilkan `random.randint(32,127)`. Namun, karena sebelum loop terdapat perintah `random.seed(0)`, maka seluruh bilangan acak yang dihasilkan dapat diprediksi dan selalu sama setiap kali dijalankan.

Dengan mengetahui seed `0`, urutan nilai `random.randint(32,127)` dapat direplikasi, sehingga enkripsi bisa dibalik secara langsung tanpa brute force. Langkah pertama adalah memecah ciphertext menjadi list integer. Kemudian jalankan ulang Python dengan `random.seed(0)` dan hasilkan urutan angka acak yang sama. XOR setiap ciphertext dengan angka acak tersebut akan memunculkan kembali flag asli. Untuk implementasinya adalah solver berikut ini:

```python
import random

s = "0x1f0x160x690x110x320x6f0x280x340x690x230xe0xb0xd0x6e0x370x20x1f0xb0x1f0xc0x4e0x30x4b0x730x730xe0x1a0x150x3f0x680xf0x730x3d0x240x7b0xa0x410x650x140x690x360x60x710x4a0x390x450x180x120x340x4e0x1b0x2f0x4e0x5f0x330x7e0x560x220x3d0x490x5c0xc0x180x41"

vals = [int(p, 16) for p in s.split('0x')[1:]]

random.seed(0)
flag = ''.join(chr(v ^ random.randint(32, 127)) for v in vals)
print(flag)
```

### Flag
NCLPS1{r4nd0m_s33d_h4ny4_s3bu4h_ps3d0_r4nd0m_d3ng4n_n1l4i_t3t4p}
